# -*- coding: utf-8 -*-
"""MOTwidth.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hvmm7UZjKJ5hieiNvpPqWDf3HKOII2IW
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.stats import linregress
from skimage import io

filepath = 'C:/Users/nuttida_ka/Pictures/2024-04-01/bias-z-axis/new/z0.65-y0.55-x0.20.tif'

plt.rcParams.update({'font.size': 14})  # Set default font size for all elements

#################### Average Value of MOT frame ####################
sumMOTarray = []
im = np.array(io.imread(filepath).astype(np.int16))
numberOfMOTFrame = 5  # Total MOT frames for each time point (half of the total frames since each pair is MOT and reference)

for t in range(11):  # Loop over time points (0-10 ms)
    for i in range(numberOfMOTFrame):  # Process each pair of frames for the current time point
        mot_index = t * 10 + i * 2
        ref_index = mot_index + 1
        
        C = im[mot_index]  # MOT frame
        A = im[ref_index]  # Reference frame

        # Average array of figure
        Area_MOT = C[0:800, 0:580]  # NO MOT AREA
        Area_back = A[0:800, 0:580]  # NO MOT AREA
        Average_MOT = C / np.sum(Area_MOT)
        Average_back = A / np.sum(Area_back)

        # Subtract background
        imc = np.zeros(im.shape[1:3])
        imc[Average_back != 0] = 1 - (Average_MOT[Average_back != 0] / Average_back[Average_back != 0])  # Background - MOT frame
        sumMOT = imc

        sumMOTarray.append(sumMOT[100:850,550:1050])  # Area of interest should be the same as above

# Plotting
fig, axs = plt.subplots(5, 2, figsize=(12, 12))
k = 0
for g in range(5):
    for p in range(2):
        if k < len(sumMOTarray):
            axs[g, p].imshow(sumMOTarray[k], cmap=None, vmin=0, vmax=1)
        k += 1
plt.tight_layout()
plt.show()

#################### Gaussian_Fit ####################
def gaussian_1d(x, amplitude, xo, sigma, baseline):
    return amplitude * np.exp(-(x - xo) ** 2 / (2 * sigma ** 2)) + baseline

# Create meshgrids for the x and y axes
x = np.arange(sumMOTarray[0].shape[1])
y = np.arange(sumMOTarray[0].shape[0])
xx, yy = np.meshgrid(x, y)

mysigmax = []
mysigmay = []

def find_max_location(arr):
    np_arr = np.array(arr)
    max_index = np.unravel_index(np.argmax(np_arr, axis=None), np_arr.shape)
    return max_index

max_location = []

# Iterate over the list of arrays
for i, data in enumerate(sumMOTarray):
    max_location.append(find_max_location(data))
    # Normalization of Data
    Normalize_data_x = np.sum(data, axis=0)
    Normalize_data_y = np.sum(data, axis=1)

    # Fit Gaussian along the x-axis
    fit_params_x, _ = curve_fit(gaussian_1d, x, Normalize_data_x, p0=[1.0, max_location[i][1], 185, 0], maxfev=10000)
    fit_data_x = gaussian_1d(x, *fit_params_x)

    # Fit Gaussian along the y-axis
    fit_params_y, _ = curve_fit(gaussian_1d, y, Normalize_data_y, p0=[1.0, max_location[i][0], 175, 0], maxfev=10000)
    fit_data_y = gaussian_1d(y, *fit_params_y)

    # Plot the original data and the fitted data for each array along both axes
    plt.figure(figsize=(10, 6))

    plt.subplot(1, 2, 1)
    plt.plot(x, Normalize_data_x, label='Original Data')
    plt.plot(x, fit_data_x, label='Fitted Gaussian')
    plt.title(f'Array {i + 1} - X-axis Gaussian Fit')
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(y, Normalize_data_y / np.trapz(fit_data_y, x=y), label='Original Data')
    plt.plot(y, fit_data_y / np.trapz(fit_data_y, x=y), label='Fitted Gaussian')
    plt.title(f'Array {i + 1} - Y-axis Gaussian Fit')
    plt.legend()

    plt.show()
    mysigmax.append(fit_params_x[2])  # sigma in x-axis
    mysigmay.append(fit_params_y[2])  # sigma in y-axis

#################### Plot Pixels**2 as a function of time**2 with error bars ####################
# Reshaping and calculating mean and standard deviation of sigma for each time point
mysigmax = np.array(mysigmax).reshape(11, numberOfMOTFrame)
mysigmay = np.array(mysigmay).reshape(11, numberOfMOTFrame)
# Replace values less than 1 with NaN
# mysigmax[mysigmax < 1] = np.nan
# mysigmay[mysigmay < 1] = np.nan
mean_sigmax = np.mean(mysigmax, axis=1)
mean_sigmay = np.mean(mysigmay, axis=1)
std_sigmax = np.std(mysigmax, axis=1)/np.sqrt(numberOfMOTFrame)
std_sigmay = np.std(mysigmax, axis=1)//np.sqrt(numberOfMOTFrame)

pixel = 13.176e-6
m = 1.443e-25  # kg
k = 1.38e-23
t = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])


# Plot settings
plt.figure(figsize=(10, 6), dpi=200)

# Plotting Sigma Y with error bars and caps
plt.errorbar((t  * 1e-3) ** 2, (mean_sigmay  * pixel) ** 2, yerr=(std_sigmay  * pixel) ** 2, fmt='o', capsize=5, label=r'$\sigma_Y$')

# Plotting Sigma X with error bars and caps
plt.errorbar((t  * 1e-3) ** 2, (mean_sigmax  * pixel) ** 2, yerr=(std_sigmax  * pixel) ** 2, fmt='o', capsize=5, label=r'$\sigma_X$')

# Linear fitting example (replace with your actual fitting)
slope_y, intercept_y = np.polyfit((t  * 1e-3) ** 2, (mean_sigmay  * pixel) ** 2, 1)
plt.plot((t  * 1e-3) ** 2, slope_y * (t  * 1e-3) ** 2 + intercept_y, label=r'Linear Fitting of $\sigma_Y$', color='blue')

slope_x, intercept_x = np.polyfit((t  * 1e-3) ** 2, (mean_sigmax  * pixel) ** 2, 1)
plt.plot((t  * 1e-3) ** 2, slope_x * (t  * 1e-3) ** 2 + intercept_x, label=r'Linear Fit of $\sigma_X$', color='orange')

# Labels, legend, and grid
plt.xlabel(r'$t^2$ (s$^2)$')
plt.ylabel(r'$\sigma^2$ (m$^2)$')
plt.legend(loc='best')
plt.grid(True)

# Show plot
plt.show()
################## CALCULATE TEMPERATURE ######################################
slopey, intercept_y, r_value_y, p_value_y, std_err_y = linregress((t * 1e-3) ** 2, (mean_sigmay * pixel) ** 2)
slopex, intercept_x, r_value_x, p_value_x, std_err_x = linregress((t * 1e-3) ** 2, (mean_sigmax * pixel) ** 2)
Tx1 = m * slopex / k
Ty1 = m * slopey / k
# Calculate standard errors of Tx1 and Ty1
std_error_Tx1 = std_err_x * m / k
std_error_Ty1 = std_err_y * m / k

# Print results in microKelvin (µK)
print(f'Tx = {Tx1 * 1e6:.2f} µK, Standard Error = {std_error_Tx1 * 1e6:.2f} µK')
print(f'Ty = {Ty1 * 1e6:.2f} µK, Standard Error = {std_error_Ty1 * 1e6:.2f} µK')
